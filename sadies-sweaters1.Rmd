---
title: "Ravelry Sweater Project, Part One"
author: "Jenna Conklin"
date: "2024-03-18"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

sweaters <- readRDS("rawdata.RDS")
```

## What Factors Generate the Most Interest in a Ravelry Sweater Pattern? 

To begin, let's imagine our protagonist, Sadie. Sadie is an amateur pattern designer who posts her patterns on Ravelry, a global platform for the fiber arts community that allows users to discover new patterns, sell or share their own patterns, post about their fiber arts projects, and engage in discussion surrounding their work. As of this writing, there are upwards of 1.3 million patterns available on Ravelry, some free, some for purchase. Sadie already sells patterns for small projects, such as hats and scarves, but she wants to expand her shop to include larger works, starting with sweaters. Before investing her effort into developing and marketing her first pattern, she hopes to understand what factors will help her generate the most interest in her work. In this project, I will retrieve a sample of highly-rated sweater patterns using the Ravelry API, conduct both exploratory and inferential analyses, and make recommendations for Sadie to take into account when developing her first sweater pattern. 

## Structure of the Project

To make it easier to navigate, this project is presented in three sections. 

1. Chapter One: Retrieve, Clean, and Organize Data
2. Chapter Two: Exploratory Data Analysis
3. Chapter Three: Inferential Analysis and Conclusions

## Retrieve Data

In this project segment, I used ravelRy, a wrapper for the Ravelry API developed by Kaylin Pavlik, as well as some tidyverse functions for data cleaning and organization. 

```{r libraries, include = FALSE}
library(ravelRy)
library(tidyverse)
library(cowplot)
```

Before connecting to the API, I created a developer's account by visiting [link] https://www.ravelry.com/pro/developer. Once my account was created, I created a new app with basic auth, read only access. Then I set the credentials I had just created as system variables labeled `RAVELRY_USERNAME` and `RAVELRY_PASSWORD`. 

```{r credentials, eval = FALSE}
Sys.setenv(RAVELRY_USERNAME = "your-username", RAVELRY_PASSWORD = "your-password")
Sys.getenv("RAVELRY_USERNAME")
Sys.getenv("RAVELRY_PASSWORD")
```

Once I gained API access, I retrieved a sample of patterns using ravelRy's `get_patterns` function. Since `get_patterns` works best on small queries of 100 - 500 lines, I used a loop to apply `get_patterns` iteratively until my sample reached my desired size of 10,000 patterns. 

Before using `get_patterns`, I used the `search_patterns` function to identify the patterns I was interested in, then used `get_patterns` to retrieve a larger set of data about each pattern of interest. For this project, I limited my search to items in the category "sweater" that appeared under a search query "sweater" and had a 5-star rating. My sample included the most recent 10,000 patterns that matched these criteria. 

```{r get data, eval = FALSE}
for (i in 1:100) {
  my_name <- paste('my_results', i, sep = "")
  assign(my_name, search_patterns(query = 'sweater', page = i, page_size = 100, rating = '5', category = 'sweater'))
  my_patterns <- paste('my_patterns', i, sep = "")
  my_id_df <- get(my_name)
  assign(my_patterns, get_patterns(ids = my_id_df$id))
  my_pattern_df <- get(paste('my_patterns', i, sep = ""))
  if (i == 1) {
    sweaters <- my_pattern_df
  }
  else {
    sweaters <- rbind(sweaters, my_pattern_df)
  }
}
```

And indeed, a dataframe containing 10,000 rows and 55 variables was retrieved! 

```{r check output, include = FALSE}
print(paste("The sweaters dataset has", nrow(sweaters), "rows and", ncol(sweaters), "columns and is of type", class(sweaters), sep = " "))
```

## Cleaning Data

To begin with, I discarded the columns I'm not interested in. 

```{r discard cols, eval=FALSE}
sweaters <- sweaters %>% select(-download_location, -currency_symbol, -url, -pdf_url, -currency, 
                        -gauge_divisor, -unlisted_product_ids, -pdf_in_library, 
                        -volumes_in_library, -gauge_description, -difficulty_count, 
                        -downloadable, -gauge_pattern, -has_uk_terminology, -has_us_terminology,
                        -permalink, -rating_count, -row_gauge, -yardage_max, 
                        -personal_attributes, -notes_html, -printings, 
                        -product_id, -ravelry_download, -created_at, -packs,  
                        -pattern_author, -photos, -pattern_type)
```

### Filter Out Non-Sweaters

Next, I wanted to confirm that all the patterns I retrieved are actually patterns I am interested in. To do this, I dug into the data nested under `pattern_categories` to determine which patterns included sweaters and which did not. Some exploration revealed that `pattern_categories$name` contained the information I am interested in, so I inspected that column.

``` {r inspect categories}
sweaters <- sweaters %>%
  hoist(pattern_categories, 
        category_subtype = "name") 

head(unique(sweaters$category_subtype))
```

As you can see, there are a number of entries that are clearly not sweaters, such as "Hanging Ornament", as well as some clothes for pets and dolls. (For brevity, I am not including full output in this summary.) To keep things relatively consistent throughout the sample, I kept patterns labeled "Pullover", "Cardigan", or "Shrug/Bolero". Many patterns have more than one label, as patterns for multiple items are included in a single listing (for instance, a matching sweater and scarf). 

```{r discard non-sweaters}
sweater_names <- c("Pullover", "Cardigan", "Shrug / Bolero") 
sweaters <- subset(sweaters, sapply(category_subtype, \(x) any(sweater_names %in% x))) 
head(unique(sweaters$category_subtype))
print(paste("The sample now contains", nrow(sweaters), "rows.", sep = " "))
```

Inspecting the data reveals that all remaining patterns now include some type of sweater, and the sample still contains 9143 patterns. Furthermore, a quick inspection of `sweaters$parent.name` reveals that I have eliminated all the pet sweaters and doll sweaters as well as the non-sweater items (truncated here for brevity). 

### Unnest and Clean Needle Size and Craft Type Data

Next, I organized the data on needle size and converted it into a usable format. To start, I pulled the data on needle size and craft type out of their nested lists. 

```{r needle size}
sweaters <- sweaters %>%
  hoist(pattern_needle_sizes, 
        needle_size_knit = "metric", 
        needle_size_crochet = "hook")%>%
  hoist(craft, 
        craft_name = "name")

unique(sweaters$craft_name)
```

The sample included not only patterns for hand-crafted items in both knitting and crochet, but also patterns for machine knitting or hand-knit items made with a knitting loom. Sadie is not well-versed in these approaches, so I filtered them out. The sample still contained plenty of data. 

```{r filter machine knits}
sweaters<- sweaters %>% 
  filter(craft_name == "Knitting" | craft_name == "Crochet")
print(paste("The sample now contains", nrow(sweaters), "rows.", sep = " "))
```

To facilitate later analysis, I created a single column containing all needle sizes offered for each pattern, selecting the correct data based on the craft type for each pattern. Since many patterns listed multiple needle sizes, I also computed the average needle size (for knit patterns only, which use numeric sizes) and the number of needle sizes listed on the pattern for future analysis. 

```{r needle size part two, warning = FALSE}
#create a single column for needle size, pulling from needle_size_knit and needle_size_crochet

sweaters <- sweaters %>%
  mutate(needle_size = case_when(craft_name == "Knitting" ~ needle_size_knit, 
                                 craft_name == "Crochet" ~ needle_size_crochet)) %>%
  select(-needle_size_knit, -needle_size_crochet)

#clean up formatting in needle_size column
#convert to string 
sweaters <- sweaters %>%
  mutate(needle_size_char = as.character(needle_size))

#remove or standardize undesirable formatting
sweaters$needle_size_cleaned <- gsub('\\"', "", as.character(sweaters$needle_size_char))
sweaters$needle_size_cleaned <- gsub("^c\\(, ", "c\\(", as.character(sweaters$needle_size_cleaned))
sweaters$needle_size_cleaned <- gsub(" , ", "", as.character(sweaters$needle_size_cleaned))
sweaters$needle_size_cleaned <- gsub(",\\)", "\\)", as.character(sweaters$needle_size_cleaned))
sweaters$needle_size_cleaned <- gsub("^$", "None Given", as.character(sweaters$needle_size_cleaned))
sweaters$needle_size_cleaned <- gsub("NULL", "None Given", as.character(sweaters$needle_size_cleaned))
sweaters$needle_size_cleaned <- gsub("c\\(\\)", "None Given", as.character(sweaters$needle_size_cleaned))
sweaters$needle_size_cleaned <- gsub(", \\)", "\\)", as.character(sweaters$needle_size_cleaned))
sweaters$needle_size_cleaned <- gsub("/", ", ", as.character(sweaters$needle_size_cleaned))
sweaters$needle_size_cleaned <- gsub("c\\(", "", as.character(sweaters$needle_size_cleaned))
sweaters$needle_size_cleaned <- gsub("\\)", "", as.character(sweaters$needle_size_cleaned))
sweaters$needle_size_cleaned <- gsub(", ", ",", as.character(sweaters$needle_size_cleaned))

#split into lists based on comma, respecting type and create columns for needle size 
#count and average needle size
sweaters <- sweaters %>%
  mutate(needle_size_list = type.convert(strsplit(needle_size_cleaned, ","), as.is = T)) %>% 
  mutate(needle_size_count = lengths(needle_size_list), 
         average_needle_size = case_when(needle_size_cleaned == "None Given" |craft_name == "Crochet" ~ list("None Given"),
                                         craft_name == "Knitting" ~ lapply(needle_size_list, mean))) %>%
  select(-pattern_categories, -craft, -pattern_needle_sizes, -needle_size_list, -needle_size_char,
         -needle_size) %>%
  mutate(needle_size = needle_size_cleaned) %>%
  select(-needle_size_cleaned)

#inspect output
head(sweaters%>%select(needle_size, needle_size_count, average_needle_size), n = 15)

```

Now the dataset contains useful columns giving the average needle size and needle size count. 

### Unnest and Clean Yarn Weight Data

Let's inspect the values given for yarn weight. 
```{r yarn weight initial} 
table(sweaters$yarn_weight_description)
```

Some of these categories can be collapsed, as they are either functionally the same or similar enough for our purposes. 

```{r yarn weight cleaning}
#clean up entries
sweaters$yarn_weight <- gsub(" \\(.*", "", as.character(sweaters$yarn_weight_description))
sweaters$yarn_weight <- gsub("^Aran$", "Aran / Worsted", sweaters$yarn_weight)
sweaters$yarn_weight <- gsub("^Worsted$", "Aran / Worsted", sweaters$yarn_weight)
sweaters$yarn_weight <- gsub("^DK$", "DK / Sport", sweaters$yarn_weight)
sweaters$yarn_weight <- gsub("^DK$", "DK / Sport", sweaters$yarn_weight)
sweaters$yarn_weight <- gsub(" - .*", "", sweaters$yarn_weight)
sweaters$yarn_weight <- sub("Light ", "", sweaters$yarn_weight)
sweaters$yarn_weight <- sub("^$", "None Given", sweaters$yarn_weight)
sweaters$yarn_weight <- sub("Cobweb", "Lace", sweaters$yarn_weight)
sweaters$yarn_weight <- sub("Thread", "Lace", sweaters$yarn_weight)
sweaters$yarn_weight <- sub("^Bulky$", "(Super) Bulky / Jumbo", sweaters$yarn_weight)
sweaters$yarn_weight <- sub("^Super Bulky$", "(Super) Bulky / Jumbo", sweaters$yarn_weight)
sweaters$yarn_weight <- sub("^Jumbo$", "(Super) Bulky / Jumbo", sweaters$yarn_weight)

#set levels of variable
sweaters$yarn_weight <- factor(sweaters$yarn_weight, levels = c(
  "Any gauge", 
  "(Super) Bulky / Jumbo",
  "Aran / Worsted", 
  "DK / Sport",      
  "Fingering",                                
  "Lace",
  "None Given" 
  ))

#inspect column
table(sweaters$yarn_weight)

#remove unneeded column
sweaters <- sweaters%>%select(-yarn_weight_description)
```

Now the dataset boasts a much more functional set of yarn weight descriptions. 

### Unnest and Clean Languages Data

Next I brought the languages data out of its nested format and created a column for the number of languages listed for each pattern. 

```{r languages} 
sweaters <- sweaters %>%
  hoist(languages, 
        language = "name") %>%
  mutate(language_count = lengths(language)) %>%
  select(-languages)


head(sweaters%>%select(language, language_count), n = 20)
```

### Calculate Length of Notes

In case the length of the written description included in the "Notes" field impacts the amount of interest the pattern generates, I computed the number of characters in that field, then removed the `notes` column itself. 

```{r notes }
sweaters <- sweaters %>%
  mutate(notes_length = nchar(notes)) %>%
  select(-notes)

summary(sweaters$notes_length)
```

As can be seen, pattern notes come in quite a range of sizes! 

### Create Variables for Pattern Attributes of Interest

Finally, I unnested and coded a few additional characteristics of the patterns that we are interested in exploring. There are many attributes we could focus on. For this analysis, I'll consider whether offering plus-sized or petite sizing has any impact on a pattern's success, as well as whether being tagged as worked in the round or flat has an impact. (In the round knitting refers to a circular style of work, spiraling around the piece as it is created, while pieces worked flat are knit in a back-and-forth manner and connected along a seam if the final product is round.)

```{r plus petite round} 
#hoist attributes data out of nested column
sweaters <- sweaters %>%
  hoist(pattern_attributes, 
        attributes = "permalink")

#create columns for plus and petite attributes and combine into one column
sweaters <- sweaters %>%
  mutate(plus = ifelse(str_detect(as.character(attributes), "plus"), T, F),
         petite = ifelse(str_detect(as.character(attributes), "petite"), T, F)) %>%
  mutate(plus_petite = case_when(plus == "TRUE" & petite == "FALSE" ~ "Plus", 
                                 plus == "FALSE" & petite == "TRUE" ~ "Petite", 
                                 plus == "FALSE" & petite == "FALSE" ~ "Neither", 
                                 plus == "TRUE" & petite == "TRUE" ~ "Both"))

#create columns for round and flat work and combine into one column
sweaters <- sweaters %>%
  mutate(in_the_round = ifelse(str_detect(as.character(attributes), "in-the-round"), T, F), 
         worked_flat = ifelse(str_detect(as.character(attributes), "worked-flat"), T, F)) %>%
  mutate(workstyle = case_when(in_the_round == "TRUE" & worked_flat == "FALSE" ~ "In the Round", 
                               in_the_round == "FALSE" & worked_flat == "TRUE" ~ "Worked Flat", 
                               in_the_round == "FALSE" & worked_flat == "FALSE" ~ "Neither", 
                               in_the_round == "TRUE" & worked_flat == "TRUE" ~ "Both"))
#display results
unique(sweaters$plus_petite)
unique(sweaters$workstyle)

#clean up columns no longer needed
sweaters <- sweaters %>% select(-pattern_attributes, -attributes, -in_the_round, -worked_flat, -plus, -petite)

```

### Compare Variables Capturing Interest in Pattern

Since sales data is not publicly available, I'll need some kind of proxy measure for interest to help Sadie predict what might help direct the most traffic to her patterns. A few promising measures include the number of comments on a pattern, the number of completed projects logged on Ravelry, the number of times users have favorited the pattern, or the number of times users have added the pattern to their queue of future planned projects. Before selecting one of these three to focus on, I examined their relative distribution through a quick scatter plot. 

```{r dependents, echo = FALSE} 
p1 <- ggplot(sweaters, aes(x=projects_count, y=queued_projects_count)) + 
  geom_point() + 
  geom_smooth() + 
  labs(x="Projects", y = "Queued Projects")

p2<- ggplot(sweaters, aes(x=favorites_count, y=queued_projects_count)) + 
  geom_point() + 
  geom_smooth() + 
  labs(x = "Favorites", y = "Queued Projects")
plot_grid(p1, p2)

print(paste("The number of patterns with zero completed projects is ", sum(sweaters$projects_count == 0), ".", sep = ""))
print(paste("The number of patterns with zero queued projects is ", sum(sweaters$queued_projects_count == 0), ".", sep = ""))
print(paste("The number of patterns with zero favorited projects is ", sum(sweaters$favorites_count == 0), ".", sep = ""))

```

As can be seen, all three are left-skewed with a few high outliers. There is a possible parabolic relationship between Projects and Queued Projects, and a possible linear relationship between Favorites and Queued Projects. Furthermore, the count of completed projects has a large number of zeroes, while the favorites count has very few zeroes. Taking all this into account, it seems likely that the completed projects count will radically underpredict interest in a pattern, since not everyone who buys a pattern will complete a project and upload it to Ravelry. Furthermore, favorites likely overpredicts interest in actually buying a pattern, since marking a pattern as a favorite signals interest, but not necessarily intent to pursue a project, while queuing a project likely signals a stronger degree of interest. Therefore, I will use Queued Projects Count as a proxy for potential sales in completing this analysis. 

### Save Cleaned Dataframe

At last, it's time to save our work and proceed to the next stage of analysis!

```{r save and close, eval = FALSE} 
write.csv(sweaters, 'cleaned_data.csv', row.names = F)
```